# 🚀 **Parallel Compaction 최적화 (8코어): Subcompaction의 스케일링 효과 분석**

## 1. 실험 동기 및 목표

### **실험 동기**
- **4코어 실험의 확장**: 기존 4코어 환경의 실험([parallel_compaction_analysis.md](parallel_compaction_analysis.md))에서 "물리적 코어 수 이상의 병렬화는 오히려 성능 저하를 유발한다"는 결론을 얻었습니다. 이 가설이 더 많은 코어를 가진 환경에서도 유효한지, 스케일링 양상이 어떻게 달라지는지 검증하고자 합니다.
- **최적점의 변화 탐구**: 코어 수가 증가함에 따라 병렬 컴팩션의 최적점이 어떻게 이동하는지, 자원 활용 패턴은 어떻게 변화하는지 정량적으로 분석하고 싶었습니다.
- **현실적인 가이드라인 제시**: 8코어와 같이 보다 일반적인 서버 환경에서 적용할 수 있는 구체적이고 실용적인 RocksDB 튜닝 가이드라인을 도출하는 것을 목표로 합니다.

### **실험 목표**
1. **스케일링 효과 심층 분석**: 8코어 환경에서 Subcompaction 수에 따른 처리량, 지연시간, 컴팩션 성능의 변화를 정량적으로 측정합니다.
2. **최적 설정값 재검증**: 8코어 하드웨어에 맞는 최적의 `subcompaction` 및 `max_background_jobs` 설정값을 도출합니다.
3. **자원 병목 현상 분석**: CPU 활용률이 포화 상태에 도달했을 때, 성능을 제한하는 다른 요인(I/O, 컨텍스트 스위칭 등)을 분석합니다.
4. **실무 적용 가이드라인 구체화**: 4코어 결과와 비교하여, 시스템 코어 수에 따른 일반화된 튜닝 전략을 제시합니다.

---

## 2. 실험 가설

### **주요 가설**
- **H1**: Subcompaction 수가 물리적 코어 수(8개)에 근접할수록 전체 처리량과 컴팩션 성능이 함께 향상될 것이다.
- **H2**: 최적 subcompaction 수는 4코어 환경(2~4개)보다 높은 값(예: 8~12개)에서 나타날 것이다.
- **H3**: 물리적 코어 수(8개)를 초과하는 과도한 병렬화(`subcompactions > 8`)는 4코어 환경에서 관찰된 것과 유사하게 컨텍스트 스위칭 오버헤드로 인해 성능이 저하되거나 정체될 것이다.

### **세부 예측**
- **최적점 예측**: 8코어 시스템에서는 `subcompactions`가 8 또는 12일 때 최고의 전체 성능(처리량, 지연시간)을 보일 것으로 예상됩니다.
- **CPU 활용률**: `subcompactions`가 8까지 증가함에 따라 CPU 사용률은 선형적으로 증가하고, 그 이후에는 100%에 가깝게 포화될 것입니다.
- **컴팩션 성능**: 컴팩션 시간은 병렬도가 증가함에 따라 지속적으로 감소하여, `subcompactions`가 8 이상인 구간에서 가장 빠를 것으로 예측됩니다.

---

## 3. 실험 설계

### **실험 환경**
```bash
# 8코어 테스트 환경
- CPU: Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz (8 cores)
- Memory: 15GiB RAM
- Storage: NVMe SSD
- OS: Ubuntu (상세 버전은 system_info.txt 참조)
- RocksDB: 10.4.0
```

### **실험 변수**
- **독립변수**: `--subcompactions`: 1, 2, 4, 8, 12, 16, 24, 32
- **종속변수**:
    - CPU 사용률 (%)
    - 컴팩션 처리량 (MB/s), 컴팩션 시간 (초)
    - 쓰기 처리량 (MB/s, ops/sec), 전체 실행 시간 (초)
    - 쓰기 지연시간 (P50, P95, P99)

### **통제 변수**
- 데이터 크기: 50,000,000 키 (약 5.5 GB)
- 키/값 크기: 16 bytes / 100 bytes
- 압축 방식: Snappy
- `max_background_jobs`: 16 (컴팩션 스레드가 부족하지 않도록 충분히 설정)

---

## 4. 실험 결과 (8코어 시스템 기준)

### **실험 데이터 종합**

`db_bench`의 `compact` 단계가 아닌, `fillrandom` 중에 발생한 모든 컴팩션 시간의 총합(`rocksdb.compaction.times.micros` SUM)을 사용하여 데이터를 재구성했습니다. 이것이 실제 쓰기 워크로드 중 발생하는 컴팩션 부하를 더 정확하게 나타냅니다. '쓰기 실행시간'은 순수 `fillrandom` 벤치마크에 소요된 시간입니다.

| Subcompactions | CPU 사용률 (%) | 컴팩션 시간 (초) | 쓰기 실행시간 (초) | 처리량 (MB/s) | Ops/sec | 평균 지연시간 (µs) |
|:--------------:|:--------------:|:----------------:|:------------------:|:-------------:|:-------:|:------------------:|
| 1              | 13.9           | 499.4            | 682.0              | 8.1           | 73,311  | 13.641             |
| 2              | 25.9           | 344.3            | 639.3              | 8.7           | 78,204  | 12.787             |
| 4              | 47.0           | 302.2            | 644.7              | 8.6           | 77,560  | 12.893             |
| 8              | 80.3           | 296.6            | 644.7              | 8.6           | 77,551  | 12.895             |
| **12**         | **84.8**       | **276.1**        | **611.6**          | **9.0**       | **81,747**  | **12.233**         |
| 16             | 78.0           | 327.8            | 726.0              | 7.6           | 68,874  | 14.519             |
| 24             | 84.5           | 299.0            | 666.9              | 8.3           | 74,971  | 13.338             |
| 32             | 75.5           | 307.4            | 664.7              | 8.3           | 75,224  | 13.293             |

---

### **분석 1: CPU 사용률 및 컴팩션 성능**

#### **CPU 사용률 분석**
```markdown
| Subcompactions | CPU 사용률 (%) | 증가율      | 효율성 등급 |
|:--------------:|:--------------:|:-----------:|:-----------:|
| 1              | 13.9           | -           | ⭐          |
| 2              | 25.9           | +86.3%      | ⭐⭐        |
| 4              | 47.0           | +81.5%      | ⭐⭐⭐      |
| 8              | 80.3           | +70.9%      | ⭐⭐⭐⭐⭐  |
| **12**         | **84.8**       | **+5.6%**   | **⭐⭐⭐⭐⭐**  |
| 16             | 78.0           | -8.0%       | ⭐⭐⭐⭐    |
| 24             | 84.5           | +8.3%       | ⭐⭐⭐⭐    |
| 32             | 75.5           | -10.7%      | ⭐⭐⭐⭐    |
```
**핵심 발견**:
- **선형 증가 구간 (1→8)**: Subcompaction이 1에서 8로 증가함에 따라 CPU 사용률이 **13.9%에서 80.3%**까지 거의 선형적으로 비례하여 증가했습니다. 이는 추가된 스레드가 유휴 CPU 코어를 효과적으로 활용했음을 의미합니다.
- **포화 및 변동 구간 (8 이상)**: `subcompactions=8`에서 물리적 코어 수만큼 스레드를 사용하며 CPU 활용률이 정점에 가까워졌고, `subcompactions=12`에서 **84.8%**로 최대치를 기록했습니다. 그 이상의 값에서는 컨텍스트 스위칭 비용 증가로 인해 오히려 CPU 사용률이 소폭 감소하거나 비효율적인 변동을 보였습니다.

#### **컴팩션 성능 분석 (순수 컴팩션 시간)**
```markdown
| Subcompactions | 컴팩션 시간 (초) | 상대 성능 (1 대비) | 성능 등급 |
|:--------------:|:----------------:|:------------------:|:-----------:|
| 1              | 499.4            | 기준               | ⭐          |
| 2              | 344.3            | -31.1%             | ⭐⭐        |
| 4              | 302.2            | -39.5%             | ⭐⭐⭐      |
| 8              | 296.6            | -40.6%             | ⭐⭐⭐⭐    |
| **12**         | **276.1**        | **-44.7%**         | **⭐⭐⭐⭐⭐**  |
| 16             | 327.8            | -34.4%             | ⭐⭐        |
| 24             | 299.0            | -40.1%             | ⭐⭐⭐⭐    |
| 32             | 307.4            | -38.4%             | ⭐⭐⭐      |
```
**핵심 발견**:
- **최적점의 일치**: 컴팩션 시간은 **`subcompactions=12`**에서 **276.1초**로 가장 빨랐습니다. 이는 subcompaction=1 대비 **44.7%** 단축된 결과입니다. 중요한 것은, 이 최적점이 **전체 성능(처리량, 지연시간)의 최적점과 일치**한다는 점입니다.
- **성능 저하 구간 (12 초과)**: `subcompactions=12`를 초과하는 지점부터는 컴팩션 시간이 다시 증가하는 경향을 보였습니다. 특히 `subcompactions=16`에서는 성능이 크게 저하되었습니다. 이는 과도한 병렬화가 컴팩션 작업 자체에도 스레드 경쟁 및 오버헤드를 유발하여 비효율을 초래함을 명확히 보여줍니다.

---

### **분석 2: 쓰기 처리량 및 지연시간 (전체 성능)**

#### **쓰기 처리량 분석**
```markdown
| Subcompactions | 처리량 (MB/s) | Ops/sec | 쓰기 실행시간 (초) | 평균 지연시간 (μs) |
|:--------------:|:-------------:|:-------:|:------------------:|:------------------:|
| 1              | 8.1           | 73,311  | 682.0              | 13.641             |
| 2              | 8.7           | 78,204  | 639.3              | 12.787             |
| 4              | 8.6           | 77,560  | 644.7              | 12.893             |
| 8              | 8.6           | 77,551  | 644.7              | 12.895             |
| **12**         | **9.0**       | **81,747**  | **611.6**          | **12.233**         |
| 16             | 7.6           | 68,874  | 726.0              | 14.519             |
| 24             | 8.3           | 74,971  | 666.9              | 13.338             |
| 32             | 8.3           | 75,224  | 664.7              | 13.293             |
```
**핵심 발견**:
- **최적점의 이동**: 4코어 환경에서는 `subcompactions=2`가 최적이었지만, 8코어 환경에서는 **`subcompactions=12`**에서 처리량(9.0MB/s), 쓰기 실행시간(611.6초), 평균 지연시간(12.2µs) 모든 면에서 최고의 "전체 성능"을 기록했습니다.
- **물리적 코어 수 초과 지점의 효율성**: 최적점이 물리적 코어 수(8개)를 약간 초과하는 `12`에서 나타난 점이 흥미롭습니다. 이는 RocksDB의 I/O 작업과 CPU 작업이 완벽하게 병렬화되지 않고, 일부 스레드가 I/O 대기 상태에 있을 때 다른 스레드가 CPU를 활용하는 식의 오버래핑(overlapping)이 발생하여 추가적인 성능 향상을 이끌어 냈을 가능성을 시사합니다.
- **과도한 병렬화의 역효과**: `subcompactions=16`부터는 처리량이 **7.6MB/s**로 급격히 하락하며 4코어 환경과 마찬가지로 "과유불급" 현상이 명확하게 관찰되었습니다. 이는 최악의 성능으로, 기본값(sub=1)보다도 느렸습니다.

#### **쓰기 지연시간 상세 분석 (Percentile)**
```markdown
| Subcompactions | P50 (μs)  | P95 (μs)  | P99 (μs)  | 지연시간 등급 |
|:--------------:|:---------:|:---------:|:---------:|:-------------:|
| 1              | 9.878     | 20.920    | 34.590    | ⭐⭐          |
| 2              | 9.125     | 19.831    | 32.742    | ⭐⭐⭐⭐      |
| 4              | 9.233     | 19.559    | 32.382    | ⭐⭐⭐⭐      |
| 8              | 9.233     | 19.474    | 32.287    | ⭐⭐⭐⭐      |
| **12**         | **8.775** | **18.448** | **30.805** | ⭐⭐⭐⭐⭐      |
| 16             | 10.923    | 21.167    | 34.562    | ⭐            |
| 24             | 9.630     | 19.920    | 32.181    | ⭐⭐⭐        |
| 32             | 9.557     | 20.091    | 32.442    | ⭐⭐⭐        |
```
**핵심 발견**:
- **지연시간 최적점**: 쓰기 지연시간 역시 **`subcompactions=12`**에서 P50, P95, P99 모두 가장 낮은 값(가장 빠름)을 기록하며, 처리량 결과와 일치하는 최적점을 보여주었습니다.
- **꼬리 지연시간(Tail Latency) 관리**: `subcompactions=12`는 평균뿐만 아니라 P99 지연시간(30.8µs)까지 안정적으로 관리하여 시스템의 전반적인 반응성을 향상시켰습니다. 반면, 성능이 가장 나빴던 `subcompactions=16`은 P99 지연시간이 34.6µs까지 치솟았습니다.

#### **2. "컴팩션 성능"과 "전체 성능"의 최적점 일치**
- **최고의 컴팩션 성능**: `subcompactions=12` (컴팩션 시간 276.1초)
- **최고의 전체 성능**: `subcompactions=12` (처리량 9.0MB/s, 쓰기 실행시간 611.6초)

이전 분석과 달리, 실제 워크로드 중의 컴팩션 시간(`rocksdb.compaction.times.micros`)을 사용하자 **컴팩션 성능과 전체 시스템 성능의 최적점이 `subcompactions=12`로 일치**했습니다. 이는 `db_bench`의 마지막 `compact` 단계는 전체 워크로드의 특성을 대표하지 못하며, 쓰기 작업과 동시에 일어나는 실제 컴팩션을 측정하는 것이 훨씬 더 중요함을 시사합니다.

#### **3. 과도한 병렬화의 성능 저하 재확인**
`subcompactions=16`에서 성능이 급격히 저하되는 현상은 4코어 실험과 동일하게 나타났습니다. 이는 물리적 자원의 한계를 넘어서는 스레드 경쟁이 CPU 컨텍스트 스위칭 비용을 급증시키고, 캐시 효율성을 떨어뜨리는 등 시스템에 심각한 부하를 준다는 가설을 강력하게 뒷받침합니다.

---

## 5. 실험 결과 해석 (8코어 시스템 기준)

### **핵심 발견사항**
#### **1. 코어 수 증가에 따른 최적점의 이동: 4코어 vs 8코어**
- **4코어 최적점**: `subcompactions=2`
- **8코어 최적점**: `subcompactions=12`

코어 수가 2배 증가했을 때, 전체 성능 최적점은 6배 증가했습니다. 이는 단순한 선형 관계가 아님을 보여줍니다. 8코어 환경에서는 더 많은 스레드를 활용하여 I/O 대기와 CPU 연산을 효과적으로 중첩시킴으로써 물리적 코어 수를 넘어서는 병렬 설정에서 성능 향상을 이끌어낼 수 있었습니다.

#### **2. "컴팩션 성능"과 "전체 성능"의 트레이드오프**
- **최고의 컴팩션 성능**: `subcompactions=12` (컴팩션 시간 276.1초)
- **최고의 전체 성능**: `subcompactions=12` (처리량 9.0MB/s, 쓰기 실행시간 611.6초)

이전 분석과 달리, 실제 워크로드 중의 컴팩션 시간(`rocksdb.compaction.times.micros`)을 사용하자 **컴팩션 성능과 전체 시스템 성능의 최적점이 `subcompactions=12`로 일치**했습니다. 이는 `db_bench`의 마지막 `compact` 단계는 전체 워크로드의 특성을 대표하지 못하며, 쓰기 작업과 동시에 일어나는 실제 컴팩션을 측정하는 것이 훨씬 더 중요함을 시사합니다.

#### **3. 과도한 병렬화의 성능 저하 재확인**
`subcompactions=16`에서 성능이 급격히 저하되는 현상은 4코어 실험과 동일하게 나타났습니다. 이는 물리적 자원의 한계를 넘어서는 스레드 경쟁이 CPU 컨텍스트 스위칭 비용을 급증시키고, 캐시 효율성을 떨어뜨리는 등 시스템에 심각한 부하를 준다는 가설을 강력하게 뒷받침합니다.

---

### **실무적 인사이트 (8코어 시스템 기준)**

#### **최적화 가이드라인 ✅**
```bash
# 8코어 시스템 권장 설정 (실험 검증 결과 기반)
# 모든 지표(처리량, 지연시간, 컴팩션)에서 최적의 성능을 보임
--subcompactions=12 --max_background_jobs=16
```

#### **설정별 성능 트레이드오프 요약**
| Subcompactions | 설정 | 컴팩션 시간 | 쓰기 실행시간 | 쓰기 처리량 | 권장 용도 |
|:--------------:|:-----------|:-------------:|:---------------:|:-------------:|:-------------------------|
| 1 | 기본값 | 499.4초 | 682.0초 | 8.1 MB/s | 부하가 거의 없는 환경 |
| 8 | 균형 설정 | 296.6초 | 644.7초 | 8.6 MB/s | 안정적인 선택지 |
| **12** | **전체 성능 최적** | **276.1초** | **611.6초** | **9.0 MB/s** | **대부분의 운영 환경에 권장** |
| 16 | 성능 최저점 | 327.8초 | 726.0초 | 7.6 MB/s | ❌ **절대 비권장** |

---

## 🎯 결론: 8코어 환경, 병렬화의 새로운 균형점을 찾다

8코어 환경에서의 실험은 4코어의 결론을 확장하고 더 깊은 이해를 제공했습니다. **"병렬화는 시스템의 물리적 코어 수와 밀접한 관련이 있지만, 최적점은 I/O 등의 다른 요인과 복합적으로 작용하여 결정된다"** 는 중요한 사실을 발견했습니다.

### 1. 핵심 결론: 모든 성능 지표의 최적점은 `subcompactions=12`로 수렴했다.
- `rocksdb.compaction.times.micros`를 사용한 정확한 분석 결과, 8코어 환경의 **전체 성능 최적점과 컴팩션 성능 최적점 모두 `subcompactions=12`** 로 나타났습니다.
- 이는 단순히 CPU 코어 수(8개)에 맞추는 것보다, CPU와 I/O 작업의 오버래핑을 고려하여 물리적 코어보다 약간 더 많은 스레드를 사용하는 것이 쓰기 처리량과 백그라운드 컴팩션 모두에 가장 유리했음을 의미합니다.

### 2. RocksDB 기본값에 대한 고찰
- RocksDB의 보수적인 기본값(`subcompaction=1`)은 어떤 환경에서도 최소한의 성능을 보장하기 위한 안전장치입니다. 하지만, 이번 8코어 실험 결과 `subcompactions=12`로 설정했을 때 기본값 대비 **처리량은 11% 향상**되고, **쓰기 실행 시간은 10% 단축**되었으며, **실제 컴팩션에 소요된 시간은 무려 45%나 감소**했습니다.
- 이는 **프로덕션 환경에서는 반드시 시스템 특성에 맞는 튜닝을 수행해야 엄청난 성능 향상을 얻을 수 있음**을 명확히 보여줍니다.

### 3. 최종 제언
- **`subcompactions` 튜닝의 시작점**: `물리적 코어 수`와 `물리적 코어 수 * 1.5` 사이의 값을 기준으로 테스트를 시작하는 것이 합리적인 전략이 될 수 있습니다.
- **종합적인 성능 측정의 중요성**: `db_bench`의 개별 벤치마크 단계(예: `compact`)의 결과만으로 판단하기보다, 실제 워크로드(예: `fillrandom`) 중에 수집된 통계(`STATISTICS`)를 종합적으로 분석하는 것이 훨씬 더 정확한 결론을 도출합니다.

이번 8코어 실험은 4코어 실험에서 얻은 "과유불급"의 교훈을 재확인하는 동시에, 멀티코어 환경의 복잡성과 잠재력을 한 단계 더 깊이 이해하는 계기가 되었습니다. 