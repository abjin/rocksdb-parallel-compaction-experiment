# 🚀 **Parallel Compaction 최적화: Subcompaction의 스케일링 효과 분석**

## 1. 실험 동기 및 목표

### **실험 동기**
- **기본값의 의문**: RocksDB의 `max_subcompactions` 기본값이 1(단일 스레드)인데, 현대 멀티코어 시대에 왜 병렬 컴팩션을 기본으로 사용하지 않는지 궁금함
- **멀티코어 활용 효과 확인**: 멀티코어 시스템에서 병렬 컴팩션이 실제로 성능 향상을 가져오는지, 아니면 오히려 성능 저하를 일으키는지 직접 실험해보고 싶음
- **최적화 지점 탐구**: 단순히 "많이 병렬화하면 좋다"가 아니라, 실제로 어느 정도의 병렬도가 최적인지 체계적으로 분석하고 싶음

### **실험 목표**
1. **스케일링 효과 정량화**: Subcompaction 수에 따른 처리량 개선 효과 측정
2. **최적 설정값 도출**: 하드웨어 스펙별 최적 subcompaction 수 결정
3. **자원 활용도 분석**: CPU, I/O 자원의 효율적 활용 방안 제시
4. **실무 가이드라인**: 프로덕션 환경 적용을 위한 구체적 설정 권장사항 도출

---

## 2. 실험 가설

### **주요 가설**
**H1**: Subcompaction 수가 증가할수록 컴팩션 처리량이 선형적으로 향상될 것이다.

**H2**: 최적 subcompaction 수는 물리적 CPU 코어 수와 강한 양의 상관관계를 가질 것이다.

**H3**: 병렬 컴팩션은 I/O 대역폭이 충분한 환경에서 더 큰 성능 향상을 보일 것이다.

**H4**: 과도한 병렬화는 컨텍스트 스위칭 오버헤드로 인해 성능 저하를 초래할 것이다.

### **세부 예측**
- 4코어 시스템: subcompaction 2-4개에서 최적점
- 16코어 시스템: subcompaction 8-12개에서 최적점  

- CPU 활용률: 병렬도 증가에 따라 향상되다가 특정 지점에서 수렴

---

## 3. 실험 설계

### **실험 환경**
```bash
# 실제 테스트 환경 (4cores)
- CPU: Intel Xeon Gold 6226R @ 2.90GHz (4 cores)
- Memory: 7.7GB RAM
- Storage: NVMe SSD
- OS: Ubuntu 22.04 LTS
```

### **실험 변수**
**독립변수**: 

- `--subcompactions`: 1, 2, 4, 8, 12, 16, 24, 32

**종속변수**:

- CPU 사용률 (%)


- 컴팩션 처리량 (MB/s)
- 컴팩션 시간 (초)
- 쓰기 처리량
- 쓰기 지연시간

### **실험 단계**

#### Phase 1: Subcompaction 변수별 실험
```bash
# 각 subcompaction 설정별 실험
for sub in 1 2 4 8 12 16 24 32; do
    echo "Testing subcompactions=$sub"
    
    # 데이터 재생성 (일관된 초기 상태)
    rm -rf /tmp/rocksdb_test_$sub
    
    # 컴팩션 성능 측정
    ./db_bench --benchmarks=fillrandom,compact \
        --db=/tmp/rocksdb_test_$sub \
        --num=50000000 \
        --subcompactions=$sub \
        --max_background_jobs=16 \
        --statistics \
        --histogram \
        --report_interval_seconds=10 > results_sub_$sub.txt
done
```

#### Phase 2: 시스템 리소스 모니터링
```bash
# 실험 중 시스템 메트릭 수집
nohup iostat -x 1 > iostat_sub_$sub.log &
nohup vmstat 1 > vmstat_sub_$sub.log &
nohup top -b -d1 -p $(pidof db_bench) > cpu_sub_$sub.log &
```



### **통제 변수**
- 데이터 크기: 5GB (일관된 워크로드)
- 키 크기: 16 bytes
- 값 크기: 100 bytes  
- 압축: Snappy (동일한 조건)
- 캐시 크기: 1GB (고정)

---



## 4. 실험 결과



### 4cores

#### **실험 환경**
```
- CPU: Intel Xeon Gold 6226R @ 2.90GHz (4 cores)
- Memory: 7.7GB RAM
- Dataset: 50M 키 (16 bytes) + 100 bytes 값
- Test Range: Subcompactions 1, 2, 4, 8, 12, 16, 24, 32
```

#### **1. CPU 사용률 분석** (vmstat 를 통해 모니터링)
```markdown
| Subcompactions | CPU 사용률 (%) | 증가율 | 효율성 등급 |
|----------------|---------------|--------|-------------|
| 1              | 28.3          | -      | ⭐⭐        |
| 2              | 51.2          | +80.9% | ⭐⭐⭐      |
| 4              | 89.0          | +73.8% | ⭐⭐⭐⭐    |
| 8              | 99.125        | +11.4% | ⭐⭐⭐⭐⭐  |
| 12             | 92.5          | -6.7%  | ⭐⭐⭐⭐    |
| 16             | 98.375        | +6.4%  | ⭐⭐⭐⭐⭐  |
| 24             | 95.0          | -3.4%  | ⭐⭐⭐⭐    |
| 32             | 94.0          | -1.1%  | ⭐⭐⭐⭐    |
```

**핵심 발견**:
- **선형 증가 구간 (1→8)**: CPU 사용률이 28.3% → 99.125%로 거의 선형 증가
- **포화점 도달**: subcompaction=8 부터 최대 CPU 활용률 달성 (99.125%)




#### **3. 컴팩션 성능 분석** 🚨
```markdown
| Subcompactions | 컴팩션 시간 (초) | 상대 성능 | 성능 등급 |
|----------------|-----------------|-----------|-----------|
| **1**          | **425**         | +43.6% 느림 | ⭐ |
| **2**          | **315**         | +6.4% 느림 | ⭐⭐⭐⭐ |
| 4              | 306             | +3.4% 느림 | ⭐⭐⭐⭐⭐ |
| 8              | 318             | +7.4% 느림| ⭐⭐⭐⭐    |
| 12             | 332             | +12.2% 느림| ⭐⭐⭐     |
| 16             | 334             | +12.8% 느림| ⭐⭐⭐     |
| 24             | 324             | +9.5% 느림| ⭐⭐⭐     |
| **32**         | **296**         | **기준**  | ⭐⭐⭐⭐⭐ |
```

**⚠️ 중요 발견**: **컴팩션 특화 vs 전체 성능** - 컴팩션만 고려하면 32가 최적이지만, 전체 시스템 성능은 subcompaction=2가 최고!

#### **4. 쓰기 처리량 분석**
```markdown
| Subcompactions | 처리량 (MB/s) | Ops/sec   | 전체 실행시간 (초) | 평균 지연시간 (μs) |
|----------------|--------------|-----------|-------------------|-------------------|
| 1              | 9.3          | 83,924    | 595.771          | 11.915           |
| **2**          | **9.4**      | **84,715** | **590.211**      | **11.804**       |
| 4              | 8.6          | 77,390    | 646.073          | 12.921           |
| 8              | 8.1          | 73,283    | 682.280          | 13.646           |
| 12             | 7.9          | 71,507    | 699.224          | 13.984           |
| **16**         | **7.8**      | **70,933** | **704.883**      | **14.098**       |
| 24             | 8.1          | 72,885    | 686.008          | 13.720           |
| 32             | 8.6          | 77,706    | 643.451          | 12.869           |
```

**핵심 발견**:
- **최적점**: subcompaction=2에서 최고 쓰기 처리량 및 최단 실행시간 달성
- **성능 저하**: 병렬도 증가 시 처리량과 지연시간 모두 악화
- **성능 차이**: 최고(subcompaction=2) vs 최악(subcompaction=16) = 20.7% 처리량 차이, 19.4% 실행시간 차이
- **컴팩션 vs 전체**: 컴팩션만으로는 subcompaction=32가 최적이지만, 전체 시스템에서는 subcompaction=2가 우수

#### **5. 쓰기 지연시간 상세 분석**
```markdown
| Subcompactions | P50 (μs) | P95 (μs) | P99 (μs) | 지연시간 등급 |
|----------------|----------|----------|----------|---------------|
| 1              | 8.650    | 14.571   | 20.512   | ⭐⭐⭐⭐⭐   |
| **2**          | **8.598** | **14.533** | **20.391** | ⭐⭐⭐⭐⭐ |
| 4              | 9.039    | 14.884   | 21.448   | ⭐⭐⭐⭐     |
| 8              | 9.415    | 15.552   | 21.636   | ⭐⭐⭐       |
| 12             | 9.670    | 17.221   | 21.904   | ⭐⭐         |
| **16**         | **9.773** | **17.545** | **21.957** | ⭐⭐ |
| 24             | 9.486    | 16.390   | 21.732   | ⭐⭐⭐       |
| 32             | 8.921    | 14.796   | 21.108   | ⭐⭐⭐⭐     |
```



#### **시스템 자원 활용도 종합**

**최적 성능 구간**:
- **CPU 활용**: subcompaction=8 (99.125% 활용률)
- **컴팩션 속도**: subcompaction=32 (296초)
- **쓰기 성능**: subcompaction=2 (9.4 MB/s)

**성능 트레이드오프**:
```
전체 성능 우선: subcompaction=2 (최고 처리량, 최단 실행시간)
컴팩션 성능 우선: subcompaction=32 (최단 컴팩션 시간)
CPU 활용 최대: subcompaction=8 (99.125% CPU 활용률)
균형 설정: subcompaction=4 (컴팩션 306초, 처리량 8.6MB/s)
```




---

## 5. 실험 결과 해석 (4코어 시스템 기준)

### **핵심 발견사항**

#### **1. 컴팩션 vs 전체 성능의 차이점 발견** 🚨
- **컴팩션 특화 최적점**: subcompaction=32에서 최단 컴팩션 시간 (296초)
- **전체 성능 최적점**: subcompaction=2에서 최고 처리량과 최단 실행시간 (9.4MB/s, 590초)
- **성능 트레이드오프**: 컴팩션 성능과 전체 시스템 성능은 다른 최적점을 가짐
- **최악 성능**: subcompaction=16에서 전체 성능 최저 (처리량 7.8MB/s, 실행시간 704초)

#### **2. 예상과 다른 성능 스케일링 패턴**
```
예상: 병렬도 증가 → 성능 향상
현실: 병렬도 증가 → 성능 저하 (4코어 시스템에서)
```
- **CPU 활용**: 선형 증가 후 포화 (1→8: 28.3% → 99.125%)
- **컴팩션 성능**: 32에서 최적 (296초), 비선형적 복잡한 패턴


### **실무적 인사이트 (4코어 시스템 기준)**

#### **최적화 가이드라인** ✅
```bash
# 4코어 시스템 권장 설정 (실험 검증 결과 기반)
1. 전체 성능 우선: --subcompactions=2 --max_background_jobs=4
   (최고 처리량 9.4MB/s, 최단 실행시간 590초)
2. 컴팩션 특화: --subcompactions=32 --max_background_jobs=8
   (최단 컴팩션 시간 296초, 처리량 8.6MB/s)
3. 균형 설정: --subcompactions=4 --max_background_jobs=8
   (컴팩션 306초, 처리량 8.6MB/s)
```

#### **설정별 성능 트레이드오프 요약**
| Subcompaction | 설정 | 컴팩션 시간 | 전체 실행시간 | 쓰기 처리량 | 권장 용도 |
|--------------|------|-------------|---------------|-------------|-----------|
| 1 | 기본 설정 | 425초 | 595초 | 9.3 MB/s | 단순 워크로드 |
| **2** | **전체 최적** | 315초 | **590초** | **9.4 MB/s** | **일반 운영 최적** |
| 4 | **균형** | 306초 | 646초 | 8.6 MB/s | 범용 설정 |
| 8 | **CPU 활용** | 318초 | 682초 | 8.1 MB/s | CPU 리소스 활용 |
| 12 | 성능 저하 시작 | 332초 | 699초 | 7.9 MB/s | ❌ 비권장 |
| 16 | 성능 최저점 | 334초 | 704초 | 7.8 MB/s | ❌ 비권장 |
| 24 | 성능 저하 지속 | 324초 | 686초 | 8.1 MB/s | ❌ 비권장 |
| **32** | **컴팩션 최적** | **296** | 643초 | 8.6 MB/s | 컴팩션 중심 워크로드 |

#### **하드웨어 한계 분석**
- **물리적 코어 한계**: 코어 개수 보다 많은 subcompaction 은 비효율 (4코어 시스템에서 subcompaction > 4는 비효율)
- **컨텍스트 스위칭 비용**: 과도한 스레드는 CPU 오버헤드 증가


## 🎯 결론: 4코어 환경에서 발견한 병렬화의 역설

이번 실험을 통해 **제한된 하드웨어(4코어) 환경에서 RocksDB의 병렬 컴팩션은 '많이'가 아니라 '알맞게' 설정해야 한다는 명확한 결론**에 도달했습니다.

### 1. 핵심 발견: "전체 성능"과 "컴팩션 성능"의 최적점은 다르다

- **최고의 전체 성능**: `subcompaction=2` 에서 달성 (쓰기 처리량 9.4MB/s, 실행시간 590초)
- **최고의 컴팩션 성능**: `subcompaction=32` 에서 달성 (컴팩션 시간 296초)

이는 컴팩션만 빠르게 하는 것과 전체 시스템 처리량을 높이는 것이 별개의 목표임을 보여줍니다. 운영 환경에서는 **전체 성능을 기준으로 최적화**하는 것이 중요합니다.

### 2. 원인 분석: 왜 병렬성이 항상 좋지 않은가?

- **물리적 코어의 한계**: 4코어 시스템에서 4개를 초과하는 병렬 작업은 컨텍스트 스위칭 비용만 증가시킬 뿐, 실제 성능 향상에는 기여하지 못했습니다.
- **CPU 활용률의 함정**: `subcompaction=8`에서 CPU 사용률은 99%로 최고였지만, 실제 처리량은 `subcompaction=2`(CPU 51%)보다 14% 낮았습니다. 높은 CPU 사용률이 항상 좋은 성능을 의미하지는 않는다는 것을 확인했습니다.

### 3. 최종 교훈 및 제언

- **기본값(1)은 이유가 있다**: RocksDB의 기본 `subcompaction=1` 설정은 무조건적인 병렬화가 오히려 성능을 해칠 수 있음을 시사합니다. 시스템 환경을 모르는 상태에서는 가장 안전한 선택입니다.
- **"Less is More"**: 4코어 환경에서는 **`subcompaction=2`** 가 전체 성능을 극대화하는 최적의 선택이었습니다.
- **맹신은 금물**: "병렬화는 좋다"는 일반적인 이론을 맹신하기보다, 실제 환경에서 직접 테스트하고 최적점을 찾는 것이 얼마나 중요한지 깨달았습니다.

이번 연구는 소규모 시스템에서 RocksDB의 성능을 최적화하는 구체적인 수치를 제시하고, **리소스 제약 환경에서 병렬 처리의 복잡성과 중요성**에 대한 깊은 이해를 제공했다는 점에서 의의가 있습니다. 