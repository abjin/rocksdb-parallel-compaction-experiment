# 🚀 **Parallel Compaction 최적화: Subcompaction의 스케일링 효과 분석**

## 1. 실험 동기 및 목표

### **실험 동기**
- **멀티코어 시대의 성능 병목**: 현대 서버는 16-64코어가 일반적이지만, 기존 RocksDB 컴팩션은 단일 스레드 기반으로 CPU 자원을 충분히 활용하지 못함
- **클라우드 환경의 비용 최적화**: AWS/GCP 등에서 vCPU 비용을 지불하면서도 실제 활용률이 낮은 문제
- **대용량 데이터 처리**: 테라바이트급 데이터에서 컴팩션이 전체 시스템 성능의 주요 병목이 되는 현실

### **실험 목표**
1. **스케일링 효과 정량화**: Subcompaction 수에 따른 처리량 개선 효과 측정
2. **최적 설정값 도출**: 하드웨어 스펙별 최적 subcompaction 수 결정
3. **자원 활용도 분석**: CPU, 메모리, I/O 자원의 효율적 활용 방안 제시
4. **실무 가이드라인**: 프로덕션 환경 적용을 위한 구체적 설정 권장사항 도출

---

## 2. 실험 가설

### **주요 가설**
**H1**: Subcompaction 수가 증가할수록 컴팩션 처리량이 선형적으로 향상될 것이다.

**H2**: 최적 subcompaction 수는 물리적 CPU 코어 수와 강한 양의 상관관계를 가질 것이다.

**H3**: 병렬 컴팩션은 I/O 대역폭이 충분한 환경에서 더 큰 성능 향상을 보일 것이다.

**H4**: 과도한 병렬화는 메모리 사용량 증가와 컨텍스트 스위칭 오버헤드로 인해 성능 저하를 초래할 것이다.

### **세부 예측**
- 4코어 시스템: subcompaction 2-4개에서 최적점
- 16코어 시스템: subcompaction 8-12개에서 최적점  
- 메모리 사용량: subcompaction 수에 비례하여 증가
- CPU 활용률: 병렬도 증가에 따라 향상되다가 특정 지점에서 수렴

---

## 3. 실험 설계

### **실험 환경**
```bash
# 하드웨어 구성
- CPU: Intel Xeon 16-core (32 threads)
- Memory: 64GB RAM
- Storage: NVMe SSD 2TB
- OS: Ubuntu 22.04 LTS
```

### **실험 변수**
**독립변수**: 

- `--subcompactions`: 1, 2, 4, 8, 12, 16, 24, 32

**종속변수**:

- CPU 사용률 (%)
- 메모리 사용량 (GB)

- 컴팩션 처리량 (MB/s)
- 컴팩션 완료 시간 (초)
- 쓰기 처리량
- 쓰기 지연시간

### **실험 단계**

#### Phase 1: Subcompaction 변수별 실험
```bash
# 각 subcompaction 설정별 실험
for sub in 1 2 4 8 12 16 24 32; do
    echo "Testing subcompactions=$sub"
    
    # 데이터 재생성 (일관된 초기 상태)
    rm -rf /tmp/rocksdb_test_$sub
    
    # 컴팩션 성능 측정
    ./db_bench --benchmarks=fillrandom,compact \
        --db=/tmp/rocksdb_test_$sub \
        --num=50000000 \
        --subcompactions=$sub \
        --max_background_jobs=16 \
        --statistics \
        --histogram \
        --report_interval_seconds=10 > results_sub_$sub.txt
done
```

#### Phase 2: 시스템 리소스 모니터링
```bash
# 실험 중 시스템 메트릭 수집
nohup iostat -x 1 > iostat_sub_$sub.log &
nohup vmstat 1 > vmstat_sub_$sub.log &
nohup top -b -d1 -p $(pidof db_bench) > cpu_sub_$sub.log &
```



### **통제 변수**
- 데이터 크기: 5GB (일관된 워크로드)
- 키 크기: 16 bytes
- 값 크기: 100 bytes  
- 압축: Snappy (동일한 조건)
- 캐시 크기: 1GB (고정)

---



## 4. 실험 결과



### 4cores

#### **실험 환경**
```
- CPU: Intel Xeon Gold 6226R @ 2.90GHz (4 cores)
- Memory: 7.7GB RAM
- Dataset: 50M 키 (16 bytes) + 100 bytes 값
- Test Range: Subcompactions 1, 2, 4, 8, 12, 16, 24, 32
```

#### **1. CPU 사용률 분석**
```markdown
| Subcompactions | CPU 사용률 (%) | 증가율 | 효율성 등급 |
|----------------|---------------|--------|-------------|
| 1              | 28.3          | -      | ⭐⭐        |
| 2              | 51.2          | +80.9% | ⭐⭐⭐      |
| 4              | 89.0          | +73.8% | ⭐⭐⭐⭐    |
| 8              | 99.125        | +11.4% | ⭐⭐⭐⭐⭐  |
| 12             | 92.5          | -6.7%  | ⭐⭐⭐⭐    |
| 16             | 98.375        | +6.4%  | ⭐⭐⭐⭐⭐  |
| 24             | 95.0          | -3.4%  | ⭐⭐⭐⭐    |
| 32             | 94.0          | -1.1%  | ⭐⭐⭐⭐    |
```

**핵심 발견**:
- **선형 증가 구간 (1→8)**: CPU 사용률이 28.3% → 99.125%로 거의 선형 증가
- **포화점 도달**: subcompaction=8에서 최대 CPU 활용률 달성 (99.125%)
- **효율성 저하**: 8 이상에서는 컨텍스트 스위칭 오버헤드로 효율성 감소

#### **2. 메모리 사용량 분석**
```markdown
| Subcompactions | 메모리 (GB) | CPU/Memory 비율 | 효율성 |
|----------------|-------------|----------------|--------|
| 1              | 0.691       | 40.95          | 낮음   |
| 2              | 1.061       | 48.25          | 보통   |
| 4              | 0.732       | 121.58         | 높음   |
| 8              | 0.744       | 133.23         | 높음   |
| 12             | 0.785       | 117.83         | 높음   |
| 16             | 0.721       | **136.6**      | **최고** |
| 24             | 0.753       | 126.16         | 높음   |
| 32             | 0.826       | 113.80         | 높음   |
```

**핵심 발견**:
- **메모리 안정성**: 0.7-0.8GB 범위에서 일관된 사용량 유지
- **예상과 다른 패턴**: 병렬도 증가에도 메모리가 선형 증가하지 않음
- **최고 효율**: subcompaction=16에서 CPU 대비 메모리 효율성 최대

#### **3. 컴팩션 성능 분석** 🚨
```markdown
| Subcompactions | 컴팩션 시간 (초) | 상대 성능 | 성능 등급 |
|----------------|-----------------|-----------|-----------|
| **2**          | **628**         | **기준**  | ⭐⭐⭐⭐⭐ |
| 1              | 662             | +5.4% 느림 | ⭐⭐⭐⭐   |
| 32             | 676             | +7.6% 느림 | ⭐⭐⭐     |
| 4              | 681             | +8.4% 느림 | ⭐⭐⭐     |
| 8              | 716             | +14.0% 느림| ⭐⭐       |
| 24             | 722             | +15.0% 느림| ⭐⭐       |
| 12             | 735             | +17.0% 느림| ⭐⭐       |
| **16**         | **740**         | **+17.8% 느림** | ⭐ |
```

**⚠️ 중요 발견**: **병렬화 역설** - 높은 병렬도가 오히려 성능 저하 초래!

#### **4. 쓰기 처리량 분석**
```markdown
| Subcompactions | 처리량 (MB/s) | Ops/sec   | 평균 지연시간 (μs) |
|----------------|--------------|-----------|-------------------|
| **2**          | **9.4**      | **84,715** | **11.804**       |
| 1              | 9.3          | 83,924    | 11.915           |
| 32             | 8.6          | 77,706    | 12.869           |
| 4              | 8.6          | 77,390    | 12.921           |
| 8              | 8.1          | 73,283    | 13.646           |
| 24             | 8.1          | 72,885    | 13.720           |
| 12             | 7.9          | 71,507    | 13.984           |
| **16**         | **7.8**      | **70,933** | **14.098**       |
```

**핵심 발견**:
- **최적점**: subcompaction=2에서 최고 쓰기 처리량 달성
- **성능 저하**: 병렬도 증가 시 처리량과 지연시간 모두 악화
- **성능 차이**: 최고(subcompaction=2) vs 최악(subcompaction=16) = 20.7% 차이

#### **5. 쓰기 지연시간 상세 분석**
```markdown
| Subcompactions | P50 (μs) | P95 (μs) | P99 (μs) | 지연시간 등급 |
|----------------|----------|----------|----------|---------------|
| **2**          | **8.598** | **14.533** | **20.391** | ⭐⭐⭐⭐⭐ |
| 1              | 8.650    | 14.571   | 20.512   | ⭐⭐⭐⭐⭐   |
| 32             | 8.921    | 14.796   | 21.108   | ⭐⭐⭐⭐     |
| 4              | 9.039    | 14.884   | 21.448   | ⭐⭐⭐⭐     |
| 8              | 9.415    | 15.552   | 21.636   | ⭐⭐⭐       |
| 24             | 9.486    | 16.390   | 21.732   | ⭐⭐⭐       |
| 12             | 9.670    | 17.221   | 21.904   | ⭐⭐         |
| **16**         | **9.773** | **17.545** | **21.957** | ⭐⭐ |
```

#### **6. 시스템 로드 및 안정성 분석**
```markdown
| Subcompactions | 시스템 로드 | 상태 평가    | 안정성 |
|----------------|-------------|-------------|--------|
| 1              | 1.367       | 정상 ✅     | 높음   |
| 2              | 2.017       | 정상 ✅     | 높음   |
| 4              | 3.025       | 주의 ⚠️     | 보통   |
| 8              | 3.152       | 주의 ⚠️     | 보통   |
| 12             | 4.126       | 과부하 🔴   | 낮음   |
| 16             | 4.614       | 과부하 🔴   | 낮음   |
| **24**         | **5.426**   | **심각** 🚨 | **위험** |
| 32             | 4.768       | 과부하 🔴   | 낮음   |
```

**안정성 기준**: 4코어 시스템에서 로드 평균 > 4.0은 시스템 과부하 상태

#### **시스템 자원 활용도 종합**

**최적 성능 구간**:
- **CPU 활용**: subcompaction=8 (99.125% 활용률)
- **메모리 효율**: subcompaction=16 (136.6 CPU/Memory 비율)
- **컴팩션 속도**: subcompaction=2 (628초)
- **쓰기 성능**: subcompaction=2 (9.4 MB/s)
- **시스템 안정성**: subcompaction=2-4 (로드 < 4.0)

**성능 트레이드오프**:
```
성능 우선: subcompaction=2 (빠른 컴팩션, 낮은 지연시간)
자원 활용: subcompaction=8 (높은 CPU 활용률)
안정성 우선: subcompaction=4 (균형잡힌 성능과 안정성)
```




---

## 5. 실험 결과 해석 (4코어 시스템 기준)

### **핵심 발견사항**

#### **1. 하드웨어 한계의 명확한 증거** 🚨
- **4코어 시스템의 병렬화 한계**: 물리적 코어 수(4) 대비 과도한 병렬화는 성능 저하 초래
- **최적점 발견**: subcompaction=2에서 최고 성능 (컴팩션 628초, 쓰기 9.4MB/s)
- **성능 역설**: subcompaction=16에서 최악 성능 (컴팩션 740초, 17.8% 성능 저하)

#### **2. 예상과 다른 성능 스케일링 패턴**
```
예상: 병렬도 증가 → 성능 향상
현실: 병렬도 증가 → 성능 저하 (4코어 시스템에서)
```
- **CPU 활용**: 선형 증가 후 포화 (1→8: 28.3% → 99.125%)
- **컴팩션 성능**: 2에서 최적, 이후 지속적 저하
- **시스템 과부하**: 로드 평균 > 4.0 시 심각한 성능 악화

#### **3. 메모리 사용 패턴 (예상과 상이)**
- **안정적 사용량**: 0.7-0.8GB 범위에서 일관성 유지
- **선형 증가 없음**: 병렬도 증가에도 메모리가 비례 증가하지 않음
- **효율성 최고점**: subcompaction=16에서 CPU/메모리 비율 136.6으로 최대

### **실무적 인사이트 (4코어 시스템 기준)**

#### **최적화 가이드라인** ✅
```bash
# 4코어 시스템 권장 설정
1. 성능 우선: --subcompactions=2 --max_background_jobs=4
2. 균형 설정: --subcompactions=4 --max_background_jobs=8  
3. 안정성 우선: --subcompactions=2 --max_background_jobs=4
```

#### **성능 vs 안정성 트레이드오프**
| 설정 | Subcompaction | 컴팩션 시간 | 쓰기 처리량 | 시스템 로드 | 권장 용도 |
|------|--------------|-------------|-------------|-------------|-----------|
| **High Performance** | 2 | 628초 | 9.4 MB/s | 2.017 | 배치 처리 |
| **Balanced** | 4 | 681초 (+8.4%) | 8.6 MB/s | 3.025 | 일반 운영 |
| **CPU Intensive** | 8 | 716초 (+14%) | 8.1 MB/s | 3.152 | CPU 활용 극대화 |
| **❌ 비권장** | 16+ | 740초+ (+17%+) | 7.8 MB/s | 4.6+ | 사용 금지 |

#### **하드웨어 한계 분석**
- **물리적 코어 한계**: 4코어 시스템에서 subcompaction > 4는 비효율
- **컨텍스트 스위칭 비용**: 과도한 스레드는 CPU 오버헤드 증가
- **시스템 과부하 임계점**: 로드 평균 > 4.0에서 성능 급격히 악화

### **실무 권장사항 (4코어 시스템 기준)**

#### **프로덕션 환경 설정**
```bash
# 4코어 시스템 (7-8GB RAM) - 실험 검증된 설정
# 최고 성능 (배치 처리용)
--subcompactions=2
--max_background_jobs=4
--max_subcompactions=2

# 균형잡힌 설정 (일반 운영용)
--subcompactions=4
--max_background_jobs=8  
--max_subcompactions=4

# ❌ 피해야 할 설정
--subcompactions=16+ (성능 저하 17%+, 시스템 불안정)
```

#### **모니터링 포인트 (4코어 특화)**
1. **시스템 로드**: 4.0 이하 유지 (과부하 방지)
2. **CPU 사용률**: 90% 이하 권장 (컨텍스트 스위칭 여유)
3. **컴팩션 지연시간**: P99 < 22μs 목표
4. **메모리 사용량**: 0.8GB 이하에서 안정적

#### **성능 경고 지표**
```
🚨 즉시 조치 필요:
- 시스템 로드 > 5.0 (subcompaction 감소)
- 컴팩션 시간 > 750초 (설정 재검토)
- P99 지연시간 > 25μs (병렬도 축소)
```

### **한계점 및 향후 연구 방향**

#### **4코어 실험의 한계**
- **하드웨어 제약**: 4코어라는 제한된 환경에서의 결과
- **스케일 확장성**: 8코어, 16코어에서의 결과와 비교 필요
- **워크로드 특성**: fillrandom + compact 패턴만 테스트

#### **추가 검증 필요 사항**
1. **다양한 코어 수**: 8코어, 16코어 시스템에서의 최적점 변화 분석
2. **실제 워크로드**: read/write 혼합 패턴에서의 병렬 컴팩션 효과
3. **메모리 크기**: 16GB, 32GB 환경에서의 스케일링 특성
4. **스토리지 타입**: HDD vs SSD vs NVMe에서의 차이점

#### **확장 연구 방향**
```
1. 멀티코어 스케일링 법칙 도출
2. 워크로드별 적응적 tuning 알고리즘
3. 클라우드 인스턴스별 최적화 프로파일
4. 실시간 성능 모니터링 기반 자동 조절
```

---

## 🎯 결론

### **4코어 시스템에서의 핵심 발견사항**

이 실험을 통해 **하드웨어 제약 환경에서의 RocksDB 병렬 컴팩션 최적화**에 대한 명확한 증거를 확보했습니다.

#### **1. 병렬화의 역설 (Parallelization Paradox)**
```
🔍 기대: subcompaction 증가 → 성능 향상
🚨 현실: subcompaction 증가 → 성능 저하 (4코어 환경)

최고 성능: subcompaction=2 (628초, 9.4MB/s)
최악 성능: subcompaction=16 (740초, 7.8MB/s, 17.8% 저하)
```

#### **2. 하드웨어 한계의 명확한 경계**
- **물리적 코어 수가 절대 기준**: 4코어를 넘는 병렬화는 비효율
- **시스템 로드 임계점**: 로드 평균 > 4.0에서 성능 급격히 악화
- **CPU 활용 vs 실제 성능**: 높은 CPU 사용률이 반드시 좋은 성능을 의미하지 않음

#### **3. 실무 적용 가이드라인**
```bash
✅ 권장 설정 (4코어 시스템):
- 성능 우선: --subcompactions=2
- 균형 설정: --subcompactions=4 
- 절대 금지: --subcompactions=16+

📊 성능 지표:
- 컴팩션 시간: 628-681초 (최적 범위)
- 쓰기 처리량: 8.6-9.4 MB/s 
- 시스템 로드: 2.0-3.0 (안정 구간)
```

### **이론과 현실의 차이**

**이론적 기대**:
- 병렬도 ↑ → 성능 ↑
- 코어 수만큼 성능 향상

**실험 결과**:
- 병렬도 ↑ → 오버헤드 ↑ → 성능 ↓
- 최적점이 예상보다 훨씬 낮음 (subcompaction=2)

### **실무적 가치**

1. **비용 최적화**: 과도한 parallelism 설정으로 인한 성능 저하 방지
2. **시스템 안정성**: 적절한 로드 유지로 시스템 과부하 예방  
3. **실증적 근거**: 추측이 아닌 실험 데이터 기반 설정 가이드라인

이 연구는 **소규모 시스템에서도 RocksDB를 효율적으로 활용**할 수 있는 구체적인 방안을 제시하며, 특히 **리소스 제약 환경에서의 성능 최적화**에 중요한 인사이트를 제공합니다. 