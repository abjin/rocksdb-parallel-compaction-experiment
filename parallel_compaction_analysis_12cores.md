# 🚀 **Parallel Compaction 최적화 (12코어): 스케일링 효과 및 병목 현상 심층 분석**

## 1. 실험 동기 및 목표

### **실험 동기**
- **코어 확장성 검증**: 4코어와 8코어 실험을 통해 "물리적 코어 수 근처에서 최적점이 형성된다"는 가설을 세웠습니다. 12코어라는 더 많은 자원이 주어진 환경에서도 이 가설이 유효한지, 성능 스케일링이 어떻게 변화하는지 검증하고자 합니다.
- **병목 현상 탐구**: CPU 코어가 충분할 때, 성능을 제한하는 새로운 병목 지점(I/O, 메모리 대역폭, 내부 락 경합 등)이 어디에서 나타나는지 분석하고 싶었습니다.
- **일반화된 튜닝 모델 수립**: 다양한 코어 수(4, 8, 12)의 실험 결과를 종합하여, 시스템 환경에 따른 최적의 `subcompaction` 설정 값을 예측할 수 있는 일반화된 가이드라인을 도출하는 것을 목표로 합니다.

### **실험 목표**
1. **성능 한계점 식별**: 12코어 환경에서 Subcompaction 수에 따른 처리량, 지연시간, 컴팩션 성능의 변화를 측정하고, 성능이 더 이상 향상되지 않는 포화 지점을 식별합니다.
2. **최적 설정값 탐색**: 12코어 하드웨어에 가장 적합한 `subcompaction` 설정값을 도출하고, 4코어/8코어 결과와 비교 분석합니다.
3. **자원 활용 패턴 분석**: CPU 코어가 더 이상 병목이 아닐 때, 어떤 시스템 자원(예: I/O wait)이 성능에 영향을 미치는지 분석합니다.
4. **통합 튜닝 가이드 제시**: 4, 8, 12코어 실험 결과를 모두 반영하여, 코어 수와 워크로드 특성에 따른 RocksDB 병렬 컴팩션 튜닝 전략을 최종적으로 제시합니다.

---

## 2. 실험 가설

### **주요 가설**
- **H1**: Subcompaction 수가 물리적 코어 수(12개)에 가까워질수록 처리량과 컴팩션 성능이 향상될 것이나, 그 효과는 8코어 환경보다 둔화될 것이다.
- **H2**: `subcompaction=8` 이상부터는 CPU 사용률이 더 이상 선형적으로 증가하지 않고, 다른 시스템 자원의 병목 현상이 관찰될 것이다.
- **H3**: 최적의 전체 성능(처리량, 지연시간)을 보이는 지점은 순수 컴팩션 성능이 가장 좋은 지점과 일치하지 않을 수 있다.
- **H4**: 12코어 환경의 최적점은 `subcompaction=8` ~ `subcompaction=12` 사이에서 나타날 것이다.

---

## 3. 실험 설계

### **실험 환경**
- **CPU**: Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz (12 cores)
- **Memory**: 29GB RAM
- **Storage**: NVMe SSD
- **OS**: Ubuntu 22.04 LTS
- **RocksDB Version**: master 브랜치 최신 버전

### **실험 변수 및 통제 변수**
- **독립 변수**: `--subcompactions` (1, 2, 4, 8, 12, 16, 24, 32)
- **종속 변수**: CPU 사용률, 컴팩션 시간, 쓰기 실행시간, 처리량, Ops/sec, 쓰기 지연시간(평균, P50, P95, P99)
- **통제 변수**: `max_background_jobs=16`, 데이터셋 5GB, Snappy 압축 등 4코어/8코어 실험과 동일한 조건으로 통제

---

## 4. 실험 결과 (12코어)

### **실험 데이터 종합**

12코어 환경에서 수집된 모든 성능 지표를 종합한 결과입니다. '컴팩션 시간'은 `fillrandom` 중 발생한 순수 컴팩션 시간의 합이며, '쓰기 실행시간'은 `fillrandom` 벤치마크에 소요된 시간입니다.

| Subcompactions | CPU 사용률 (%) | 컴팩션 시간 (초) | 쓰기 실행시간 (초) | 처리량 (MB/s) | Ops/sec  | 평균 지연시간 (µs) |
|:--------------:|:--------------:|:----------------:|:------------------:|:-------------:|:--------:|:------------------:|
| 1              | 9.0            | 362.1            | 505.4              | 10.9          | 98,931   | 10.108             |
| 2              | 21.4           | 275.9            | 510.5              | 10.8          | 97,950   | 10.209             |
| 4              | 33.2           | 241.7            | 516.2              | 10.7          | 96,856   | 10.325             |
| **8**          | **61.0**       | **219.9**        | **513.9**          | **10.8**      | **97,292**| **10.278**         |
| 12             | 65.2           | 233.9            | 517.6              | 10.7          | 96,604   | 10.352             |
| 16             | 59.7           | 225.5            | 521.0              | 10.6          | 95,978   | 10.419             |
| **24**         | **73.9**       | **219.3**        | **510.3**          | **10.8**      | **97,989**| **10.205**         |
| 32             | 64.0           | 214.0            | 515.0              | 10.7          | 97,085   | 10.300             |

---

### **주요 지표 상세 분석**

#### **1. CPU 사용률 분석**

- **선형 증가 구간 (1 → 8)**: Subcompaction이 1에서 8로 증가함에 따라 CPU 사용률은 9%에서 61%까지 꾸준히 증가합니다. 이는 코어 추가 할당이 효율적으로 이루어지고 있음을 의미합니다.
- **성능 비효율 구간 (8 → 12)**: Subcompaction을 8에서 12로 늘렸을 때, CPU 사용률은 61%에서 65.2%로 **단 4.2%p 증가**에 그쳤습니다. 이는 코어를 50%나 더 사용했음에도 불구하고 효율이 크게 떨어짐을 의미하며, **컨텍스트 스위칭 오버헤드나 다른 리소스 경합**이 발생하고 있음을 시사합니다.
- **이상 현상 (12 → 16)**: Subcompaction을 16으로 늘리자 CPU 사용률이 오히려 59.7%로 감소하는 이상 현상이 나타났습니다. 이는 과도한 병렬화로 인한 비효율이 극대화되었음을 보여줍니다.
- **최대 사용률**: `subcompaction=24`에서 73.9%로 가장 높은 사용률을 보였지만, 8코어 환경에서 85%까지 사용된 것과 비교하면 효율이 떨어집니다.

#### **2. 컴팩션 성능 분석**

- **최적점**: `subcompaction=32`에서 **214초**로 가장 빠른 컴팩션 시간을 기록했습니다. `subcompaction=8`(219.9초)과 `subcompaction=24`(219.3초) 지점도 거의 유사한 성능을 보입니다.
- **성능 개선폭**: `subcompaction=1`(362.1초) 대비 `subcompaction=32`는 **41%의 시간 단축**을 보여줍니다.
- **결론**: 코어 수가 늘어남에 따라 순수 컴팩션 작업 자체는 더 많은 병렬 처리를 통해 이점을 얻을 수 있는 것으로 보입니다. 하지만 전체 성능과의 연관성은 별도로 분석해야 합니다.

#### **3. 쓰기 처리량 및 실행 시간 분석**

- **최고 처리량**: `subcompaction=1`에서 **10.9MB/s**로 역설적으로 가장 높은 처리량을 기록했습니다. 하지만 이는 컴팩션이 거의 발생하지 않은 초기 상태의 성능이므로 실질적인 최적점으로 보기는 어렵습니다.
- **안정적인 고성능 구간**: `subcompaction=2, 8, 24`에서 모두 **10.8MB/s**라는 안정적인 처리량을 보였습니다.
- **쓰기 실행시간**: 처리량과 반비례 관계를 보이며, `subcompaction=1`에서 505.4초로 가장 짧았고, 나머지 설정에서는 510초 내외에서 안정화되었습니다.
- **결론**: 12코어 환경에서는 일정 수준(`subcompaction >= 2`) 이상의 병렬화가 쓰기 성능에 큰 영향을 주지 못하고, 비슷한 수준에 머무르는 **성능 포화(Saturation)** 현상이 뚜렷하게 나타납니다.

#### **4. 쓰기 지연시간 상세 분석 (P50, P95, P99)**

| Subcompactions | P50 (µs) | P95 (µs) | P99 (µs) |
|:--------------:|:--------:|:--------:|:--------:|
| **1**          | **7.566**| 17.655   | 30.981   |
| 2              | 7.630    | 17.167   | 31.170   |
| 4              | 7.584    | 17.406   | 32.757   |
| 8              | 7.710    | 15.929   | 30.721   |
| 12             | 7.728    | 16.804   | 31.331   |
| 16             | 7.786    | 16.025   | 30.792   |
| 24             | 7.651    | 15.996   | 31.109   |
| **32**         | **7.759**| **15.471**| **30.737**|

- **P99 (Tail Latency)**: P99 지연시간은 대부분의 설정에서 약 31µs 내외로 매우 안정적인 모습을 보입니다. 이는 12코어 환경의 충분한 자원으로 인해 꼬리 지연시간이 잘 제어되고 있음을 의미합니다.
- **P95**: `subcompaction=32`에서 15.471µs로 가장 좋은 P95 값을 보여줍니다.
- **결론**: 지연 시간 측면에서는 `subcompaction` 값에 따른 극적인 변화가 관찰되지 않았습니다. 모든 설정에서 안정적인 지연 시간을 제공하므로, 12코어 환경에서는 처리량과 자원 효율성이 더 중요한 선택 기준이 됩니다.

---

## 5. 실험 결과 해석 (12코어 시스템 기준)

### **핵심 발견사항**

1.  **성능 스케일링의 한계 도달**: 8코어 환경과 달리, 12코어 환경에서는 `subcompaction` 수를 늘려도 쓰기 처리량이 더 이상 향상되지 않는 **성능 포화 현상**이 명확하게 나타났습니다. `subcompaction=2` 이상부터는 처리량이 10.7~10.8MB/s 범위에 머물렀습니다.
2.  **CPU 효율성 저하가 병목**: `subcompaction`이 8을 초과하면서부터 CPU 사용률 증가가 둔화되고, 16에서는 오히려 감소하는 현상이 나타났습니다. 이는 **과도한 병렬 스레드로 인한 컨텍스트 스위칭 비용**이 유효한 CPU 작업 시간을 잠식하기 시작했음을 의미합니다. CPU 자체가 병목의 원인이 된 것입니다.
3.  **처리량과 컴팩션 성능의 분리**: 쓰기 처리량은 `subcompaction=2`부터 이미 최대치에 도달했지만, 순수 컴팩션 시간은 `subcompaction=32`까지 계속해서 개선되었습니다. 이는 두 성능 지표의 최적점이 다르다는 기존의 가설을 다시 한번 입증합니다.

### **실무적 인사이트 (12코어 시스템 기준)**

#### **최적화 가이드라인**
- **균형잡힌 최적 설정 (Balanced Optimal)**: **`subcompaction=8`**
  - **이유**: 적절한 CPU 사용률(61%)을 보이면서, 최고 수준의 처리량(10.8MB/s)과 우수한 컴팩션 성능(219.9초)을 모두 달성하는 가장 균형 잡힌 지점입니다. 더 많은 코어를 사용해도 성능 향상이 거의 없으므로, **`subcompaction=8`** 이 가장 효율적인 선택입니다.
- **컴팩션 성능 우선 설정**: `subcompaction=32`
  - **이유**: 쓰기 처리량을 약간(1.8%) 희생하는 대신, 가장 빠른 컴팩션(214초) 성능을 얻을 수 있습니다. 쓰기보다 백그라운드 작업 부하가 더 중요한 특수 환경에서 고려할 수 있습니다.
- **비권장 설정**: `subcompaction > 12`
  - **이유**: 12코어 환경에서 12개를 초과하는 병렬 컴팩션 스레드는 명백한 성능 저하 또는 비효율을 유발했습니다. 특히 `subcompaction=16`에서는 CPU 사용률이 감소하는 등 이상 현상이 발생했으므로 권장하지 않습니다.

---

## 🎯 결론: 코어 확장성의 한계와 새로운 병목의 발견

이번 12코어 실험은 4코어, 8코어 실험을 거쳐 얻은 결론을 더욱 공고히 하고, **리소스가 풍부한 환경에서의 새로운 병목 현상**을 이해하는 중요한 계기가 되었습니다.

### 1. 최종 결론: 물리적 코어 수가 절대적 기준은 아니다

- 4코어에서는 `subcompaction=2`, 8코어에서는 `subcompaction=12`가 최적이었던 반면, 12코어에서는 **`subcompaction=8`** 이 가장 효율적인 최적점으로 나타났습니다.
- 이는 단순히 물리적 코어 수에 비례하여 `subcompaction`을 설정하는 것이 아니라, **특정 지점을 넘어서면 컨텍스트 스위칭 오버헤드로 인해 오히려 효율이 떨어진다**는 것을 명확히 보여줍니다.

### 2. 통합 분석: 코어 수에 따른 튜닝 전략

| 코어 수 | 권장 `subcompaction` | 특징                               | 주된 병목 현상               |
|:-------:|:--------------------:|:-----------------------------------|:-----------------------------|
| 4코어   | **2**                | 전체 성능(처리량) 극대화           | 물리적 코어 부족             |
| 8코어   | **12**               | CPU 활용률과 성능이 모두 최고      | CPU 포화 시작, I/O 경합 발생 |
| 12코어  | **8**                | 성능 포화, 자원 효율성 최적        | 컨텍스트 스위칭 오버헤드     |

이 결과를 통해 **시스템 코어 수의 약 2/3 ~ 1배수 사이**에서 최적의 `subcompaction` 값을 찾는 것이 효과적인 출발점이라는 실용적인 가이드라인을 도출할 수 있습니다.

### 3. 최종 제언

- **자원 효율성을 고려한 튜닝**: 시스템에 코어가 많다고 해서 무조건 `subcompaction`을 높이는 것은 낭비입니다. 12코어 환경에서는 `subcompaction=8`로도 충분히 최대 성능을 이끌어낼 수 있었습니다. 남는 CPU 자원은 다른 애플리케이션에 할당하는 것이 전체 시스템 효율에 더 유리합니다.
- **성능 포화 지점 테스트의 중요성**: 모든 시스템에는 성능 포화 지점이 존재합니다. 실제 운영 환경과 유사한 조건에서 부하 테스트를 통해 이 지점을 파악하고, **최소한의 리소스로 최대 효율을 내는 지점**을 찾는 것이 현대적인 데이터베이스 튜닝의 핵심입니다.

이번 3단계에 걸친 실험을 통해, RocksDB 병렬 컴팩션은 시스템 환경에 매우 민감하게 반응하며, "많을수록 좋다"는 단순한 접근이 아닌 **시스템의 한계를 이해하고 균형점을 찾는 정교한 접근**이 필요함을 입증했습니다. 