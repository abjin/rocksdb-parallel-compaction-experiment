# 🚀 RocksDB 병렬 컴팩션 최종 성능 분석 보고서

## 1. 서론

### 연구 배경 및 문제 제기
RocksDB는 현대 데이터베이스 시스템의 핵심 엔진이지만, 기본 설정, 특히 `max_subcompactions` 값은 `1`로 고정되어 있습니다. 이는 멀티코어 시대에 "왜 병렬 컴팩션을 기본으로 사용하지 않는가?"라는 근본적인 의문을 제기합니다. 단순히 "병렬화는 좋다"는 일반론을 넘어, 어느 정도의 병렬도가 최적인지, 그리고 과도한 병렬화가 오히려 성능을 저해하지는 않는지 체계적인 분석이 필요합니다.

### 연구 목표
본 연구는 두 가지 체계적인 실험을 통해 RocksDB의 병렬 컴팩션 성능을 심층적으로 분석하고, 실무에 적용 가능한 구체적인 튜닝 가이드라인을 제시하는 것을 최종 목표로 합니다.

---

## 2. 실험 1: 기본 설정(`subcompactions=1`)의 한계 분석

### 0. 실험 동기 및 목표
- **동기**: RocksDB의 보수적인 기본 설정(`subcompactions=1`)이 멀티코어 환경의 자원을 얼마나 비효율적으로 사용하고 있는지 정량적으로 확인하고, 병렬 튜닝의 필요성을 입증하고자 합니다.
- **목표**: 코어 수가 다른(4, 8, 12코어) 환경에서 기본 설정의 성능을 비교하여, 멀티코어 환경에서의 성능 한계와 자원 낭비 실태를 명확히 분석합니다.

### 1. 가설
- **H1**: `subcompactions=1` 설정에서는 코어 수가 증가하더라도 성능이 비례하여 향상되지 않고, 오히려 특정 구간에서 성능이 저하되는 비일관적인 모습을 보일 것입니다.
- **H2**: 코어 수가 많은 환경일수록 단일 스레드 작업으로 인한 CPU 자원 낭비가 심화될 것입니다.

### 2. 실험 설계
- **독립 변수**: 시스템의 물리적 코어 수 (4, 8, 12코어)
- **통제 변수**:
    - `subcompactions`: 1 (고정)
    - 데이터셋 크기: 5GB
- **종속 변수**: CPU 사용률, 처리량(MB/s), 쓰기 실행 시간(초), 컴팩션 시간(초), 평균 지연시간(µs)

### 3. 실험 결과
| 지표 / 코어 수 | 4코어 환경 | 8코어 환경 | 12코어 환경 |
|:---|:---:|:---:|:---:|
| **CPU 사용률 (%)** | 28.3% | 13.9% | 9.0% |
| **처리량 (MB/s)** | 9.3 MB/s | 8.1 MB/s | **10.9 MB/s** |
| **쓰기 실행시간 (초)** | 595.7 초 | 682.0 초 | **505.4 초** |
| **컴팩션 시간 (초)** | 425.0 초 | 499.4 초 | **362.1 초** |
| **평균 지연시간 (μs)**| 11.9 µs | 13.6 µs | **10.1 µs** |

### 4. 해석
- **자원 활용의 역설**: 12코어 환경에서 최고의 성능을 냈음에도 불구하고 CPU 사용률이 9%에 그쳐, **가용 자원의 91%가 낭비되고 있음**을 확인했습니다. 이는 코어 수 증가가 애플리케이션의 성능 향상으로 직결되지 않음을 보여주는 명백한 증거입니다.
- **성능 비일관성**: 가설대로 코어 수가 4개에서 8개로 늘었을 때 오히려 성능이 저하되는 현상이 발생했습니다. 이는 기본 설정만으로는 시스템 리소스를 예측 가능하게 사용할 수 없음을 의미합니다.
- **결론**: RocksDB의 기본 설정은 어떤 환경에서도 최소한의 동작을 보장하기 위한 '안전장치'일 뿐, 성능을 위한 최적의 값이 아닙니다. 따라서, 멀티코어 환경에서는 시스템의 잠재력을 최대한 활용하기 위해 **병렬 컴팩션 튜닝이 선택이 아닌 필수**임을 이 실험은 명확히 보여줍니다.

---

## 3. 실험 2: 4코어 환경에서의 병렬 컴팩션 최적화

### 0. 실험 동기 및 목표
- **동기**: 실험 1을 통해 튜닝의 필요성을 확인했다면, 이제 실제 운영 환경을 가정한 실용적인 최적값을 찾고자 합니다. 이론적인 분석을 넘어, 리소스가 제한된 현실적인 상황에서 **최종 사용자 경험에 직결되는 '전체 시스템 성능'을 극대화**하는 최적의 튜닝 설정을 찾는 것을 목표로 삼았습니다.
- **목표**: 4코어라는 제한된 환경에서 `subcompactions` 값을 변경하며, 전체 시스템 처리량을 극대화하는 최적의 설정값을 찾습니다.

### 1. 가설
- **H1**: 전체 성능(처리량, 지연시간)의 최적점과, 순수 컴팩션 속도의 최적점은 서로 다른 `subcompaction` 값에서 나타나, 성능 트레이드오프 관계가 존재할 것입니다.
- **H2**: 최적의 전체 성능은 물리적 코어 수(4개)보다 적거나 비슷한 수준(`subcompactions` 2~4)에서 나타날 것이며, 이를 초과하는 병렬화는 컨텍스트 스위칭 비용으로 인해 성능 저하를 유발할 것입니다.

### 2. 실험 설계
- **독립 변수**: `subcompactions` (1, 2, 4, 8, 12, 16, 24, 32)
- **통제 변수**:
    - 시스템 코어 수: 4코어 (고정)
    - 데이터셋 크기: 5GB, 키 16B, 값 100B
- **종속 변수**: CPU 사용률, 컴팩션 시간, 쓰기 실행 시간, 처리량(MB/s), 지연시간(평균, P50, P95, P99)

### 3. 실험 결과

#### 성능 종합 테이블
| Subcompactions | 처리량 (MB/s) | 쓰기 실행시간 (초) | 컴팩션 시간 (초) | CPU 사용률 (%) |
|:--------------:|:---------------:|:------------------:|:----------------:|:--------------:|
| 1              | 9.3             | 595.8              | 425              | 28.3%          |
| **2**          | **9.4**         | **590.2**          | 315              | 51.2%          |
| 4              | 8.6             | 646.1              | **306**          | 89.0%          |
| 8              | 8.1             | 682.3              | 318              | 99.1%          |
| 16             | 7.8             | 704.9              | 334              | 98.4%          |
| 32             | 7.7             | 722.4             | 343              | 94.0%          |

#### 쓰기 지연시간 상세 분석 (μs)
| Subcompactions | P50 (μs) | P95 (μs) | P99 (μs) |
|:--------------:|:----------:|:----------:|:----------:|
| 1              | 8.650    | 14.571   | 20.512   |
| **2**          | **8.598**| **14.533**| **20.391**|
| 4              | 9.039    | 14.884   | 21.448   |
| 8              | 9.415    | 15.552   | 21.636   |
| 16             | 9.773    | 17.545   | 21.957   |
| 32             | 10.21    | 18.48    | 24.62    |

### 4. 해석
- **'전체 성능'과 '컴팩션 성능'의 명확한 분리**: 가설대로, 두 지표의 최적점은 완전히 달랐습니다. 최고의 **전체 성능(처리량 9.4MB/s, 실행시간 590.2초, P99 지연시간 20.39µs)은 `subcompactions=2`**에서 달성된 반면, 가장 빠른 **컴팩션 속도(306초)는 `subcompactions=4`**에서 나타났습니다. 이는 사용자 체감 성능과 시스템 내부 최적화가 서로 다른 튜닝 포인트를 가진다는 중요한 발견입니다.
- **적정 병렬화의 중요성**: `subcompactions=2`에서 전체 성능이 최고점에 도달한 후, `subcompactions=4`를 넘어서면서 성능이 급격히 저하되었습니다. 특히 `subcompactions=8` 이상에서는 처리량이 지속적으로 감소하여 `subcompactions=32`에서는 처리량이 7.7MB/s로 최적점 대비 18%나 떨어졌습니다. 이는 **물리적 코어 수의 절반 수준에서 전체 성능이 최적화**됨을 시사합니다.
- **CPU 활용률의 함정**: `subcompactions=8`에서 CPU 사용률은 99.1%로 포화 상태에 이르렀지만, 실제 처리량은 오히려 `subcompactions=2`보다 14%나 낮았습니다. 이는 높은 CPU 사용률이 좋은 성능을 보장하지 않음을 증명합니다. 유효한 작업을 처리하기보다 스레드 간 컨텍스트 스위칭에 대부분의 CPU 자원이 소모되면서, **너무 높은 CPU 사용률 자체가 성능의 병목**으로 작용한 것입니다.
- **결론**: 4코어 환경에서 최적의 **전체 시스템 성능은 `subcompactions=2`** (물리 코어의 1/2)에서, **컴팩션 단일 작업 성능은 `subcompactions=4`** (물리 코어와 동일)에서 달성되었습니다. 실무에서는 전체 시스템 처리량과 사용자 경험을 우선시해야 하므로, **물리적 코어 수의 절반 수준으로 설정**하는 것이 RocksDB 성능 최적화의 핵심 원칙입니다.

---

## 4. 종합 결론 및 제언

### 핵심 결론

**첫째, RocksDB의 기본 설정(`subcompactions=1`)은 멀티코어 시대에 심각한 자원 낭비를 초래합니다.** 12코어 환경에서도 CPU 사용률이 9%에 그쳐 91%의 자원이 낭비되고 있으며, 코어 수 증가가 성능 향상과 비례하지 않는 비일관적인 결과를 보였습니다. 이는 RocksDB의 기본 설정이 '안전장치' 역할일 뿐, 성능 최적화를 위한 설정이 아님을 명백히 보여줍니다. 따라서 멀티코어 환경에서는 병렬 컴팩션 튜닝이 선택이 아닌 필수입니다.

**둘째, 최적의 병렬 컴팩션 성능은 물리적 코어 수와 균형을 맞출 때 달성됩니다.** 4코어 환경에서 진행한 체계적 실험 결과, 전체 시스템 성능(처리량 9.4MB/s, P99 지연시간 20.39µs)은 `subcompactions=2`에서 최고치를 기록했습니다. 물리적 코어 수를 초과하는 병렬화(`subcompactions=8` 이상)는 컨텍스트 스위칭 비용만 증가시켜 오히려 성능을 14% 이상 저하시켰습니다. 특히 CPU 사용률이 99%에 달해도 실제 처리량은 감소하는 '병렬화의 역설'을 확인했습니다.
